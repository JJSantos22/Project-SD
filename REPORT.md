Primeiramente, a arquitetura gossip é um protocolo de comunicação distribuída que permite a vários nodes de uma rede partilhar e propagar informação de maneira descentralizada, comunicando com vizinhos, até a informação chegar a rede toda. 
Aplicando este protocolo ao nosso caso prático tivemos que fazer algumas adaptações ao algoritmo. 
Uma vez que os servidores são identificados por qualificadores, optamos por criar mapas associando qualificadores aos timestamps para manter os registos da informação recebida, sendo que cada servidor tem ainda dois mapas, o timestamps (TS) e o replicaTimeStamps (replicaTS). O timestamps guarda as operações adicionadas ao ledger, que já foram executadas, sendo definitivo. Por outro lado, o replicaTS guarda as atualizações que já foram recebidos, mas ainda não foram processadas, logo ainda não está garantido que serão realizadas – uma implicação disto é que, dentro de um servidor, o replicaTS será sempre menor ou igual que o TS. Já no lado do cliente (User e Admin) optámos por definir um mapa com N entradas, que irá guardar os pedidos enviados e as respetivas respostas do servidores.
A arquitetura gossip cobre 3 tipos de operações: pedidos de leituras, de escrita, e update/propagação de estado entre servidores.
Do lado do cliente, as operações de escrita e de leitura são iniciadas pelo envio ao servidor de um request que guarda o pedido e o timestamps do cliente (prevTS) e recebe um response do servidor com a resposta ao pedido e o merge da replicaTS do servidor com o prevTS. 
Já do lado do servidor o processo é ligeiramente mais complexo, especialmente em operações de escrita. Depois de recebido um request, o replicaTS será atualizado com a receção dum novo pedido guardado que ainda não foi processado. O replicaTS será atribuído ao Operations prevTS. De seguida, começamos por verificar se o prevTS criado é menor ou igual do TS do server (então o servidor está atualizado com que o cliente que mandou o pedido), logo esta operação será estável. Caso contrário a operação até poderá ser registada no ledger, mas não será realizada.
Para processar as operações de updates, sempre que uma operação é executada num dos servidores o TS dessa operação é comparado com o da replicaTS do outro servidor. Se o TS da operação for superior ao da réplica significa que essa operação ainda não foi realizada neste servidor. De seguida, esse TS irá ser comparado com o TS do novo servidor (para verificar a estabilidade da operação esse server) - se a operação for  considerada estável, será executada e consequentemente atualizará o valor do TS do server. 
Finalmente nas operações de propagação de estado, o raciocínio é muito semelhante ao do update. Um servidor recebe o ledger de outro servidor, o replicaTS do primeiro é atualizado e é verificado se é necessário realizar alguma atualização entre os recebido e o guardado. No caso de existir, estas são tratadas como no ponto acima. 


